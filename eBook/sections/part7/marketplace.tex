\section{Defining Requirements for a Marketplace Contract}

In this section, we define the essential requirements for our marketplace contract. The contract should include the following checks:

\begin{itemize}
    \item \textbf{Owner's Actions:} An owner can cancel or create a listing in the contract.
    \item \textbf{Buyer Limitation:} A buyer can purchase only one NFT at a time to avoid double-spending, a potential issue to be explained later.
    \item \textbf{NFT Transfer:} Ensure that the NFT is correctly transferred to the buyer upon purchase.
    \item \textbf{Seller Payment:} The contract must ensure that the seller receives the correct payment.
    \item \textbf{Marketplace Payment:} The marketplace fee must be paid correctly.
    \item \textbf{Royalties:} If royalties are present, they must be paid to the designated address.
\end{itemize}

The contract will store the following information for each NFT listing:

\begin{itemize}
    \item \texttt{nSeller} :: \texttt{PubKeyHash} \texttt{the address to pay}
    \item \texttt{nPrice} :: \texttt{Integer} \texttt{the amount}
    \item \texttt{nCurrency} :: \texttt{CurrencySymbol} \texttt{the policy of the token}
    \item \texttt{nToken} :: \texttt{TokenName} \texttt{the asset name of the token}
    \item \texttt{nRoyalty} :: \texttt{PubKeyHash} \texttt{the address of the royalty recipient}
    \item \texttt{nRoyaltyPercent} :: \texttt{Integer} \texttt{the percentage of royalty}
\end{itemize}

\section{Implementing Marketplace Contracts in Plutus, Helios, Aiken, OpShin, and plut-ts}

To implement marketplace contracts, we will begin by analyzing the contract implementation in \textbf{PlutusTX}. We can refer to the [JPG Store contract repository](https://github.com/jpg-store/current-jpg-store-contracts/blob/main/src/Market/Onchain.hs).

In the repository, we can see how the marketplace contract is implemented in \texttt{Onchain.hs}, which defines the main logic and transaction validation.

\subsection{PlutusTX Code for Marketplace Contract}

We provide the following code implementation for the market contract in Plutus:

\begin{lstlisting}[language=haskell, caption=Plutus Code for Marketplace Contract]
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE NumericUnderscores         #-}

module Market.Onchain
    ( apiBuyScript
    , buyScriptAsShortBs
    , typedBuyValidator
    , Sale
    , buyValidator
    , nftDatum
    ) where

import qualified Data.ByteString.Lazy     as LB
import qualified Data.ByteString.Short    as SBS
import           Codec.Serialise          ( serialise )

import           Cardano.Api.Shelley      (PlutusScript (..), PlutusScriptV1)
import qualified PlutusTx
import PlutusTx.Prelude
import PlutusTx.Ratio
import Ledger
    ( TokenName,
      PubKeyHash(..),
      CurrencySymbol,
      DatumHash,
      Datum(..),
      txOutDatum,
      txSignedBy,
      ScriptContext(scriptContextTxInfo),
      TxInfo,
      TxInInfo(..),
      txInfoInputs,
      txOutDatumHash,
      Validator,
      TxOut,
      txInfoSignatories,
      unValidatorScript, valuePaidTo )
import qualified Ledger.Typed.Scripts      as Scripts
import qualified Plutus.V1.Ledger.Scripts as Plutus
import           Ledger.Value              as Value ( valueOf )
import qualified Plutus.V1.Ledger.Ada as Ada (fromValue, Ada (getLovelace))

import           Market.Types               (NFTSale(..), SaleAction(..))

{-# INLINABLE nftDatum #-}
nftDatum :: TxOut -> (DatumHash -> Maybe Datum) -> Maybe NFTSale
nftDatum o f = do
    dh <- txOutDatum o
    Datum d <- f dh
    PlutusTx.fromBuiltinData d

{-# INLINABLE ensureOnlyOneScriptInput #-}
ensureOnlyOneScriptInput :: ScriptContext -> Bool
ensureOnlyOneScriptInput ctx =
  let
    isScriptInput :: TxInInfo -> Bool
    isScriptInput i = case (txOutDatumHash . txInInfoResolved) i of
      Nothing -> False
      Just _ -> True
  in if length (filter isScriptInput $ txInfoInputs (scriptContextTxInfo ctx)) <= 1
       then True
       else False

{-# INLINABLE mkBuyValidator #-}
mkBuyValidator :: PubKeyHash -> NFTSale -> SaleAction -> ScriptContext -> Bool
mkBuyValidator pkh nfts r ctx =
    case r of
        Buy   -> traceIfFalse "NFT not sent to buyer" checkNFTOut &&
                 traceIfFalse "Seller not paid" checkSellerOut &&
                 traceIfFalse "Fee not paid" checkMarketplaceFee &&
                 traceIfFalse "Royalities not paid" checkRoyaltyFee &&
                 traceIfFalse "More than one script input" onlyOneScriptInput
        Close -> traceIfFalse "No rights to perform this action" checkCloser
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx

    tn :: TokenName
    tn = nToken nfts

    cs :: CurrencySymbol
    cs = nCurrency nfts

    seller :: PubKeyHash
    seller = nSeller nfts

    sig :: PubKeyHash
    sig = case txInfoSignatories info of
            [pubKeyHash] -> pubKeyHash
            _ -> error ()

    price :: Integer
    price = nPrice nfts

    checkNFTOut :: Bool
    checkNFTOut = valueOf (valuePaidTo info sig) cs tn == 1

    marketplacePercent :: Integer
    marketplacePercent = 20

    marketplaceFee :: Ratio Integer
    marketplaceFee = max (1_000_000 % 1) (marketplacePercent % 1000 * fromInteger price)

    checkMarketplaceFee :: Bool
    checkMarketplaceFee
      = fromInteger (Ada.getLovelace (Ada.fromValue (valuePaidTo info pkh)))
      >= marketplaceFee

    royaltyFee :: Ratio Integer
    royaltyFee = max (1_000_000 % 1) (nRoyaltyPercent nfts % 1000 * fromInteger price)

    checkRoyaltyFee :: Bool
    checkRoyaltyFee = if nRoyaltyPercent nfts > 0
      then fromInteger (Ada.getLovelace (Ada.fromValue (valuePaidTo info $ nRoyalty nfts))) >= royaltyFee
      else True

    checkSellerOut :: Bool
    checkSellerOut
      =  fromInteger (Ada.getLovelace (Ada.fromValue (valuePaidTo info seller)))
      >= ((fromInteger price - marketplaceFee) - royaltyFee)

    checkCloser :: Bool
    checkCloser = txSignedBy info seller

    onlyOneScriptInput :: Bool
    onlyOneScriptInput = ensureOnlyOneScriptInput ctx


data Sale
instance Scripts.ValidatorTypes Sale where
    type instance DatumType Sale    = NFTSale
    type instance RedeemerType Sale = SaleAction


typedBuyValidator :: PubKeyHash -> Scripts.TypedValidator Sale
typedBuyValidator pkh = Scripts.mkTypedValidator @Sale
    ($$(PlutusTx.compile [|| mkBuyValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode pkh)
    $$(PlutusTx.compile [|| wrap ||])
  where
    wrap = Scripts.wrapValidator @NFTSale @SaleAction


buyValidator :: PubKeyHash -> Validator
buyValidator = Scripts.validatorScript . typedBuyValidator

buyScript :: PubKeyHash -> Plutus.Script
buyScript = Ledger.unValidatorScript . buyValidator

buyScriptAsShortBs :: PubKeyHash -> SBS.ShortByteString
buyScriptAsShortBs = SBS.toShort . LB.toStrict . serialise . buyScript

apiBuyScript :: PubKeyHash -> PlutusScript PlutusScriptV1
apiBuyScript = PlutusScriptSerialised . buyScriptAsShortBs
\end{lstlisting}

\subsection{Types.hs Code for Marketplace Contract}

Here is the code for \texttt{types.hs}, which defines the datum structures used in the marketplace contract:

\begin{lstlisting}[language=haskell, caption=Types Code for Marketplace Contract]
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeOperators         #-}

module Market.Types
    ( NFTSale (..)
    , SaleAction (..)
    , SaleSchema
    , StartParams (..)
    , BuyParams (..)
    )
    where

import           Data.Aeson                (ToJSON, FromJSON)
import           GHC.Generics              (Generic)
import           Prelude                   (Show (..))
import qualified Prelude                   as Pr

import           Schema                    (ToSchema)
import qualified PlutusTx
import           PlutusTx.Prelude          as Plutus ( Eq(..), (&&), Integer )
import           Ledger                    ( TokenName, CurrencySymbol, PubKeyHash )
import           Plutus.Contract           ( Endpoint, type (.\/) )

-- This is the datum type, carrying the previous validator params
data NFTSale = NFTSale
    { nSeller          :: !PubKeyHash
    , nPrice           :: !Integer
    , nCurrency        :: !CurrencySymbol
    , nToken           :: !TokenName
    , nRoyalty :: !PubKeyHash
    , nRoyaltyPercent :: !Integer
    } deriving (Pr.Eq, Pr.Ord, Show, Generic, ToJSON, FromJSON, ToSchema)

instance Eq NFTSale where
    {-# INLINABLE (==) #-}
    a == b = (nSeller    a == nSeller    b) &&
             (nPrice     a == nPrice     b) &&
             (nCurrency  a == nCurrency  b) &&
             (nToken     a == nToken     b) &&
             (nRoyalty a == nRoyalty b) &&
             (nRoyaltyPercent a == nRoyaltyPercent b)

PlutusTx.makeIsDataIndexed ''NFTSale [('NFTSale, 0)]
PlutusTx.makeLift ''NFTSale


data SaleAction = Buy | Close
    deriving Show

PlutusTx.makeIsDataIndexed ''SaleAction [('Buy, 0), ('Close, 1)]
PlutusTx.makeLift ''SaleAction


-- We define two different params for the two endpoints start and buy with the minimal info needed.
-- Therefore the user doesn't have to provide more that what's needed to execute the said action.
{- For StartParams we ommit the seller
    because we automatically input the address of the wallet running the startSale enpoint

   For BuyParams we ommit seller and price
    because we can read that in datum which can be obtained with just cs and tn of the sold token -}

data BuyParams = BuyParams
    { bCs :: CurrencySymbol
    , bTn :: TokenName
    } deriving (Pr.Eq, Pr.Ord, Show, Generic, ToJSON, FromJSON, ToSchema)


data StartParams = StartParams
    { sPrice :: Integer
    , sCs    :: CurrencySymbol
    , sTn    :: TokenName
    , sRoyaltyAddress :: !PubKeyHash
    , sRoyaltyPercent :: !Integer
    } deriving (Pr.Eq, Pr.Ord, Show, Generic, ToJSON, FromJSON, ToSchema)


type SaleSchema = Endpoint "close" BuyParams .\/ Endpoint "buy" BuyParams .\/ Endpoint "start" StartParams
\end{lstlisting}
The process is straightforward: when a seller wishes to list an NFT for sale, they send the NFT to the marketplace contract address and attach the correct datum. This allows the seller to retain the ability to cancel the listing later if they change their mind.

A buyer can purchase the NFT by fulfilling the following conditions: 
\begin{itemize}
    \item Paying the correct amount to the seller.
    \item Paying the applicable fees to the marketplace.
    \item Paying royalties, if any are set.
    \item Purchasing only one NFT at a time.
\end{itemize}

You don't need to fully grasp every detail of the contract at this moment. This book is here to guide you through the learning process, not to overwhelm you with technicalities. Let's simplify the contract and break it down into more accessible terms with other programming languages.

\subsection{Helios marketplace}
\subsection{Opshin marketplace}
\subsection{Plu-ts marketplace}
\subsection{Aiken marketplace}



\section{Testing and Deploying Marketplace Contracts}

In this section, we will focus on the steps necessary for testing and deploying the marketplace contracts. This involves simulating transactions, verifying contract behavior, and deploying the contract on a Cardano testnet before going live.

\section{Enhancing Marketplace Contracts with Additional Features}

In this section, we explore potential enhancements for the marketplace contracts. These could include adding new features like auction support, bidding systems, or enhancing security by implementing advanced validation techniques. We will also discuss how we can extend the contract to support multi-asset marketplaces and integrate additional services.
